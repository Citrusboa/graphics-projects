<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<!-- The above 3 meta tags *must* come first in the head; any other head content must come *after* these tags -->
	<title>CS 488/688: Introduction to Computer Graphics</title>

	<!-- Bootstrap -->
	<link href="bootstrap/css/bootstrap.min.css" rel="stylesheet">

	<!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
	<!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
	<!--[if lt IE 9]>
	<script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
	<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
	<![endif]-->

	<!-- Custom styles for this template -->
	<link href="bootstrap/css/carousel.css" rel="stylesheet">

	<style>
		/* Customize container */
		@media (min-width: 800px) {
			.container {
				max-width: 800px;
			}
		}
		.container-narrow > hr {
			margin: 30px 0px;
		}
		dd {
			padding-bottom: 10px;
			padding-left: 10px;
		}
		dl {
			padding-bottom: 0px;
		}
	</style>
</head>


<body role="document">


<div class="container" role="main">
<center>
	<h2>CS 488/688: Introduction to Computer Graphics</h2>
	<h4>Assignment 2: Ray tracing</h4><hr>
</center>


<h3>Summary</h3>

<p>
Latest GPUs support hardware-accelerated ray tracing and it is getting increasingly popular to use ray tracing for interactive applications. You may have seen something like "ray tracing is offline rendering and rasterization for interactive rendering", but that is no longer true. Ray tracing is capable of doing something difficult with rasterization only, albeit it can be computationally more expensive. The goal of this assignment is to write a simple ray tracer that can do (at least) the following:
</p>

<ol>
	<li>Intersect primary rays with scene geometry;</li>
	<li>Cast shadow rays from intersection points to each light source; and</li>
	<li>Use the gathered information to perform illumination calculations and compute the pixel value based on shading.</li>
</ol>

<div class="alert alert-info" role="alert">
You can take your own extended <code>cs488.h</code> from A1 as a starting point. Doing so allows you to use your own rasterizer to perform interactive rendering of an object before running ray tracing. If your rasterization is correctly implemented, it also helps you to debug your ray tracer since you can generate some reference images. However, you can still complete all the tasks in A2 even if you failed everything in A1.
</div>

<div class="alert alert-warning" role="alert">
Just like A1, do NOT just use hardware ray tracing on GPUs by calling ray tracing APIs (or any other external libraries) and call this assignment done. You will get zero points. This course is not about how to use such libraries and APIs. We would like you to go through the fundamentals of ray tracing so that you have a solid foundation to use whatever future ray tracing libraries you might use after taking this course!
</div>

<h3>Task 0: main.cpp</h3>
<p>
Comment out <code>A1(argc, argv)</code> and comment in <code>A2(argc, argv)</code> to enable a simple setup code in <code>main.cpp</code>. That being said, the only difference from <code>A1(argc, argv)</code> is that now we set <code>globalRenderType = RENDER_RAYTRACE;</code>. This variable now tells the framework to run in a ray tracing mode. You can toggle between different rendering modes by pressing the "R" key. If the code runs, you just see a window that shows nothing. Again, it is not a bug; your task is to make it render something interesting (and consistent with rasterization in most cases).
</p>



<h3>Task 1: Ray-triangle intersection</h3>
<p>
Look for <code>bool raytraceTriangle(HitInfo& result, const Ray& ray, const Triangle& tri)</code> in the TriangleMesh class. The function is currently empty. Implement a ray-triangle intersection code and fill in <code>result</code> with a proper hit information. You would like to interpolate normals and texture coordinates via barycentric coordinates. Be sure to normalize the interpolated normal. The function should return true when there is a valid intersection between <code>tMin</code> and <tMax>, and return false otherwise. If everything is done right, loading cornelbox.obj results in this image, which is exactly the same as the results of rasterization (i.e., toggling with the R key would not change the image, except that you now don't need proper clipping). 
</p>
<center>
	<img style="max-width : 75%" src="a2_res/t1.png"/>
</center><br>

<div class="alert alert-info" role="alert">
Your ray tracing mode will be significantly slower than rasterization. Do not expect interactive performance except for a something very simple like cornellbox.obj. The extra credit will be about accelerating ray tracing. You can also tell the base code to show the progress of ray tracing, rather than trying to show an entire image once it is done (which can take seconds and minutes for something complex) by <code>globalShowRaytraceProgress = true</code> with some overhead.
</div>




<h3>Task 2: Shadow ray tracing</h3>
<p>
Look for <code>static float3 shade</code>. At the moment, the code returns at <code>return brdf * PI; //debug output</code> that just returns the reflectance of the Lambertian material. Comment out that line to enable illumination computation for a point light source. Implement a shadow ray tracing to properly account for shadows from a point light source. You may want to start tracing from a hit point of the eye ray, and check if there is an intersection between the light source and the hit point. Here is an image without shadow ray tracing:
</p>
<center>
	<img style="max-width : 75%" src="a2_res/t2noshadow.png"/>
</center><br>
<p>
which will become the following with shadow ray tracing. 
</p>
<center>
	<img style="max-width : 75%" src="a2_res/t2shadow.png"/>
</center><br>

<div class="alert alert-info" role="alert">
What is noteworthy is that, if this task was done right, even if you switch to the rasterization mode by pressing the R key, you will still see proper shadows. You did not implement anything for shadow in rasterization (e.g., shadow mapping), so you may wonder why. It is because you now rasterize the first visible point from the camera for each pixel, and then you trace a shadow ray to account for shadows. You now have a hybrid of rasterization and ray tracing, which is becoming a norm in AAA video games as of 2023! You may also notice that shadow rays are traced for those pixels that end up being overdrawn by other pixels. This observation leads to the idea of deferred shading.
</div>


<h3>Task 3: Specular reflection</h3>
<p>
Look for <code>static float3 shade</code> again. Right now, the code path for <code>else if (hit.material->type == MAT_METAL)</code> is empty. Implement a recursive ray tracing to support specular reflection. You get an image like this (disabled lighting and shadow to make reflection visible):
<center>
	<img style="max-width : 75%" src="a2_res/t3.png"/>
</center><br>
<p>
Note that <code>viewDir</code> by default is pointing away from the surface. You may also want to utilize <code>level</code> there.
</p>



<h3>Task 4: Specular refraction </h3>
<p>
Look for <code>static float3 shade</code> yet again. The code path for <code>else if (hit.material->type == MAT_GLASS)</code> is empty. Implement a recursive ray tracing to support specular refraction that consider a proper index of refraction. Be sure to check if your ray is entering or existing from an object to calculate a refracted ray direction. This task is similar to Task 3. We might add an example image here later.
</p>


<h3>Task 5: Environment mapping </h3>
<p>
Implement environment mapping so that a ray that did not hit anything will get a value from a panoramic image. You may use the loading feature of the Image class. You do not need to implement image-based lighting (which is an extra task), but the environment map should be visible through specular reflection and refraction. We might add an example image here later.
</p>


<h3>Extras</h3>
<p>
These are optional extra tasks for those of you who would like more challenges and potentially gain extra points. Specification of an extra task is intentionally very-high level. Explain what you did in README if you want an extra point. You may or may not receive an extra point depending on our evaluation.
</p>

<h3>Extra 1: Faster ray tracing</h3>
<p>
Implement bounding volume hierarchy to accelerate ray tracing. You can utilize the existing code in <code>cs488.h</code>. Report the performance boost. You should consider using the surface area heuristic. You can also do any further optimization, except for using other libraries or APIs. Make your ray tracer as fast as possible!
</p>

<h3>Extra 2: Image-based lighting</h3>
<p>
Environment maps right now does not affect anything on <code>MAT_LAMBERTIAN</code> (diffuse surfaces). Implement image-based lighting so that they are now properly illuminated by an environment map. Be sure to trace shadow rays to account for occlusion.
</p>



<h3>What to submit</h3>
<p>
The submission process for this assignment is basically the same as the one for Assignment 0. Prepare a ZIP file of your code, omitting unnecessary files (executables, build files, etc.). Upload the ZIP file to LEARN.
</p>
<p>As with Assignment 0, you <em>must</em> submit the <code>README</code>. In this assignment, you need to provide multiple screenshots to demonstrate what you achieved in each task. Name them as <code>screenshotTask2.png</code> etc., to clarify which task you are referring to. If you omit either of the files, you will receive a deduction. See <a href="a0.html">Assignment 0</a> for instructions about how to prepare these files. 
</p>
<div class="alert alert-info" role="alert">
While you can use them as your references, you are not required to render the same images as in this page (but you still should be able to if you use the same files). You may choose different .obj files to demonstrate your results. 
</div>
<p>
If you do extend the base code, be sure to document your extensions in your <code>README</code> file. Keep in mind that
you must still satisfy the core objectives listed here. If your changes are so radical that your modified program is 
incompatible with the original specification, you must include a "compatibility mode" that makes the interface behave like the requirements here, or consider creating an entirely separate project (but hey, is that making sense?).
</p>
<p>
If you are using your own .obj file to render images, be sure to include them in your submission. That being said, do not include a too large .obj file. 
</p>




<h3>Other thoughts</h3>
<p>
After completing this assignment, your code is now ready for both interactive and non-interactive applications. In fact, your rendering system is a hybrid of rasterization and ray tracing, which is the state of the art in 3D graphics as of 2023. Think about how you might want to extend or any additional techniques you might want to implement on top of it. Those are great candidates for your final project. It will not hurt for you to start implementing those features. We can still take those account in the final project as long as you do not claim points in this assignment. 
</p>
<p>
At this point, you might want to check out how the .obj loader converts the values from .mtl (material definition file for .obj) to the material definitions in the base code. You can extend this part to have more variation of materials and that might help you to later load a more complex .obj file in the final project.
</p>



<h3>Objectives</h3>
<p>
Every assignment includes a list of objectives. Your mark in the assignment will be based primarily on the achievement of these objectives, with possible deductions outside the list if necessary.
</p>

<ol>
	<li>
	Ray-triangle intersection is returning correct hit/miss.
	</li>
	<li>
	HitInfo is filled in properly. 
	</li>
	<li>
	Shadow is properly rendered by shadow ray tracing.
	</li>
	<li>
	Specular reflection is working correctly.
	</li>
	<li>
	Specular refraction is working correctly.
	</li>
	<li>
	Environment map is loaded and used properly.
	</li>
</ol>




    <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.3/jquery.min.js"></script>
    <!-- Include all compiled plugins (below), or include individual files as needed -->
    <script src="bootstrap/js/bootstrap.min.js"></script>
  </body>
</html>
